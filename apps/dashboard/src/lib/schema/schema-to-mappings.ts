/**
 * Schema-to-Mappings Auto-Inference
 *
 * Parses DemokitSchema (from projectSources.parsedSchema) and generates
 * default endpoint-to-data-model mappings for the SDK.
 *
 * This powers the zero-config drop-in replacement for DemoKit SDK.
 */

import type { DemokitSchema } from '@demokit-ai/core'

/**
 * HTTP methods we support for endpoint mappings
 */
export type SupportedHttpMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE'

/**
 * Response type for endpoint mappings
 */
export type EndpointResponseType = 'collection' | 'single' | 'custom'

/**
 * An inferred endpoint mapping (before validation/saving to DB)
 */
export interface InferredEndpointMapping {
  /** HTTP method */
  method: SupportedHttpMethod
  /** URL pattern with :param placeholders (e.g., "/api/users/:id") */
  pattern: string
  /** Key in fixture data to use as source (e.g., "users") */
  sourceModel: string
  /** Response type: collection (array) or single (object) */
  responseType: EndpointResponseType
  /** For 'single' type: field in data to match against (e.g., "id") */
  lookupField?: string
  /** For 'single' type: URL param name to use for lookup (e.g., "id", "userId") */
  lookupParam?: string
  /** Whether this mapping was auto-generated */
  isAutoGenerated: boolean
  /** Confidence score (0-100) for this inference */
  confidence: number
  /** Reasoning for this mapping */
  reason?: string
}

/**
 * Result of endpoint mapping inference
 */
export interface InferEndpointMappingsResult {
  /** Successfully inferred mappings */
  mappings: InferredEndpointMapping[]
  /** Endpoints that couldn't be mapped (need manual config or AI validation) */
  unmapped: UnmappedEndpoint[]
  /** Endpoints that were skipped (not suitable for mocking) */
  skipped: SkippedEndpoint[]
  /** Available models from fixture data */
  availableModels: string[]
}

/**
 * An endpoint that couldn't be automatically mapped
 */
export interface UnmappedEndpoint {
  method: SupportedHttpMethod
  path: string
  reason: string
  suggestedModel?: string
}

/**
 * An endpoint that was skipped (not suitable for mocking)
 */
export interface SkippedEndpoint {
  method: string
  path: string
  reason: string
}

/**
 * Endpoints that should be skipped (not suitable for demo data mocking)
 */
const SKIP_PATTERNS = [
  /^\/health/i,
  /^\/healthz/i,
  /^\/ready/i,
  /^\/readyz/i,
  /^\/live/i,
  /^\/livez/i,
  /^\/(api\/)?v\d+\/health/i,
  /^\/auth\//i,
  /^\/login/i,
  /^\/logout/i,
  /^\/oauth/i,
  /^\/callback/i,
  /^\/webhook/i,
  /^\/hooks?\//i,
  /^\/stripe\//i,
  /^\/payments?\/webhook/i,
  /^\/_next\//i,
  /^\/_internal\//i,
  /^\/\.well-known\//i,
  /^\/sitemap/i,
  /^\/robots\.txt/i,
  /^\/favicon/i,
  /^\/metrics/i,
  /^\/actuator/i,
  /^\/graphql$/i,
  /^\/ws\//i,
  /^\/socket/i,
]

/**
 * HTTP methods that should be skipped
 */
const SKIP_METHODS = new Set(['HEAD', 'OPTIONS', 'TRACE', 'CONNECT'])

/**
 * Check if an endpoint should be skipped
 */
function shouldSkipEndpoint(method: string, path: string): { skip: boolean; reason?: string } {
  // Skip unsupported methods
  if (SKIP_METHODS.has(method.toUpperCase())) {
    return { skip: true, reason: `Unsupported HTTP method: ${method}` }
  }

  // Check against skip patterns
  for (const pattern of SKIP_PATTERNS) {
    if (pattern.test(path)) {
      return { skip: true, reason: `Path matches skip pattern: ${pattern.source}` }
    }
  }

  return { skip: false }
}

/**
 * Normalize OpenAPI path parameters to Express-style
 * @example "/users/{id}" -> "/users/:id"
 * @example "/orders/{orderId}/items/{itemId}" -> "/orders/:orderId/items/:itemId"
 */
export function normalizePathPattern(path: string): string {
  return path.replace(/\{([^}]+)\}/g, ':$1')
}

/**
 * Extract path parameter names from a path
 * @example "/users/:id" -> ["id"]
 * @example "/orders/:orderId/items/:itemId" -> ["orderId", "itemId"]
 */
export function extractPathParams(path: string): string[] {
  const matches = path.match(/:([a-zA-Z_][a-zA-Z0-9_]*)/g)
  if (!matches) return []
  return matches.map((m) => m.slice(1)) // Remove the leading ":"
}

/**
 * Extract the likely model name from an endpoint path
 *
 * Uses heuristics to find the resource name:
 * - Looks for plural nouns in the path
 * - Handles nested resources (e.g., /users/:id/posts -> "posts")
 * - Handles versioned paths (e.g., /api/v1/users -> "users")
 *
 * @example "/api/v1/users" -> "users"
 * @example "/users/:id" -> "users"
 * @example "/users/:userId/orders" -> "orders"
 * @example "/products/:productId/reviews/:reviewId" -> "reviews"
 */
export function extractModelFromPath(path: string): string | null {
  // Normalize path and split into segments
  const normalized = normalizePathPattern(path)
  const segments = normalized.split('/').filter(Boolean)

  // Filter out common prefixes and parameters
  const resourceSegments = segments.filter((segment) => {
    // Skip version prefixes
    if (/^v\d+$/i.test(segment)) return false
    // Skip api prefix
    if (segment.toLowerCase() === 'api') return false
    // Skip path parameters
    if (segment.startsWith(':')) return false
    return true
  })

  // The last segment is typically the resource name
  const lastSegment = resourceSegments[resourceSegments.length - 1]
  if (!lastSegment) return null

  // Convert to lowercase and return
  return lastSegment.toLowerCase()
}

/**
 * Normalize a string for comparison by removing underscores and lowercasing
 * @example "order_items" -> "orderitems", "OrderItems" -> "orderitems"
 */
function normalizeForComparison(str: string): string {
  return str.toLowerCase().replace(/_/g, '')
}

/**
 * Find matching model in available fixture models
 *
 * Handles case differences and common transformations:
 * - users -> Users, users, User
 * - orderItems -> order_items, OrderItems
 * - order_items -> OrderItems, orderItems
 */
export function findMatchingModel(
  inferredModel: string,
  availableModels: string[]
): { model: string; confidence: number } | null {
  if (!inferredModel) return null

  const normalized = inferredModel.toLowerCase()

  // Exact match (case-insensitive)
  const exactMatch = availableModels.find((m) => m.toLowerCase() === normalized)
  if (exactMatch) {
    return { model: exactMatch, confidence: 100 }
  }

  // Singular/plural matching
  const singular = normalized.endsWith('s') ? normalized.slice(0, -1) : normalized
  const plural = normalized.endsWith('s') ? normalized : normalized + 's'

  const singularMatch = availableModels.find((m) => m.toLowerCase() === singular)
  if (singularMatch) {
    return { model: singularMatch, confidence: 90 }
  }

  const pluralMatch = availableModels.find((m) => m.toLowerCase() === plural)
  if (pluralMatch) {
    return { model: pluralMatch, confidence: 90 }
  }

  // Normalized comparison (removes underscores, lowercases everything)
  // This handles order_items <-> OrderItems <-> orderItems
  const normalizedInput = normalizeForComparison(inferredModel)
  const normalizedMatch = availableModels.find(
    (m) => normalizeForComparison(m) === normalizedInput
  )
  if (normalizedMatch) {
    return { model: normalizedMatch, confidence: 80 }
  }

  // Try normalized comparison with singular/plural
  const normalizedSingular = normalizedInput.endsWith('s')
    ? normalizedInput.slice(0, -1)
    : normalizedInput
  const normalizedPlural = normalizedInput.endsWith('s')
    ? normalizedInput
    : normalizedInput + 's'

  const normalizedSingularMatch = availableModels.find(
    (m) => normalizeForComparison(m) === normalizedSingular
  )
  if (normalizedSingularMatch) {
    return { model: normalizedSingularMatch, confidence: 75 }
  }

  const normalizedPluralMatch = availableModels.find(
    (m) => normalizeForComparison(m) === normalizedPlural
  )
  if (normalizedPluralMatch) {
    return { model: normalizedPluralMatch, confidence: 75 }
  }

  return null
}

/**
 * Determine the lookup field for single-record responses
 *
 * The lookup field is always what we match against in the fixture data.
 * For path parameters like "productId" or "orderId", we keep the original
 * param name as the lookupField since that's what the SDK will use.
 *
 * @example pathParams: ["id"] -> lookupField: "id"
 * @example pathParams: ["userId"] -> lookupField: "userId"
 * @example pathParams: ["productId", "reviewId"] -> lookupField: "reviewId"
 */
export function determineLookupField(pathParams: string[], _modelName: string): string {
  if (pathParams.length === 0) return 'id'

  // Use the last path parameter as the lookup field
  const lastParam = pathParams[pathParams.length - 1]

  return lastParam
}

/**
 * Determine response type based on HTTP method and path structure
 */
export function determineResponseType(
  method: SupportedHttpMethod,
  path: string,
  _pathParams: string[]
): EndpointResponseType {
  // GET requests
  if (method === 'GET') {
    // If path ends with a parameter, it's a single-record lookup
    const normalizedPath = normalizePathPattern(path)
    const segments = normalizedPath.split('/').filter(Boolean)
    const lastSegment = segments[segments.length - 1]

    if (lastSegment?.startsWith(':')) {
      return 'single'
    }

    // Otherwise it's a collection
    return 'collection'
  }

  // POST creates a new record (returns single)
  if (method === 'POST') {
    return 'single'
  }

  // PUT/PATCH updates a record (returns single)
  if (method === 'PUT' || method === 'PATCH') {
    return 'single'
  }

  // DELETE removes a record (returns single or nothing)
  if (method === 'DELETE') {
    return 'single'
  }

  return 'collection'
}

/**
 * Main function: Infer endpoint mappings from a DemokitSchema
 *
 * @param schema - The parsed DemokitSchema from projectSources
 * @param fixtureModelNames - Available model names from fixture data (keys of fixtureGenerations.data)
 */
export function inferEndpointMappings(
  schema: DemokitSchema,
  fixtureModelNames: string[]
): InferEndpointMappingsResult {
  const mappings: InferredEndpointMapping[] = []
  const unmapped: UnmappedEndpoint[] = []
  const skipped: SkippedEndpoint[] = []

  for (const endpoint of schema.endpoints) {
    const { method, path } = endpoint

    // Check if endpoint should be skipped
    const skipCheck = shouldSkipEndpoint(method, path)
    if (skipCheck.skip) {
      skipped.push({
        method,
        path,
        reason: skipCheck.reason || 'Matched skip pattern',
      })
      continue
    }

    // Filter to supported methods
    if (!isSupportedMethod(method)) {
      skipped.push({
        method,
        path,
        reason: `Unsupported HTTP method: ${method}`,
      })
      continue
    }

    const supportedMethod = method as SupportedHttpMethod

    // Extract path parameters
    const normalizedPath = normalizePathPattern(path)
    const pathParams = extractPathParams(normalizedPath)

    // Try to infer the model from the path
    const inferredModelName = extractModelFromPath(path)

    if (!inferredModelName) {
      unmapped.push({
        method: supportedMethod,
        path,
        reason: 'Could not extract model name from path',
      })
      continue
    }

    // Try to match with available fixture models
    const modelMatch = findMatchingModel(inferredModelName, fixtureModelNames)

    if (!modelMatch) {
      unmapped.push({
        method: supportedMethod,
        path,
        reason: `No matching model found for "${inferredModelName}"`,
        suggestedModel: inferredModelName,
      })
      continue
    }

    // Determine response type
    const responseType = determineResponseType(supportedMethod, path, pathParams)

    // Build the mapping
    const mapping: InferredEndpointMapping = {
      method: supportedMethod,
      pattern: normalizedPath,
      sourceModel: modelMatch.model,
      responseType,
      isAutoGenerated: true,
      confidence: modelMatch.confidence,
      reason: `Inferred "${modelMatch.model}" from path segment "${inferredModelName}"`,
    }

    // Add lookup configuration for single-record responses
    if (responseType === 'single' && pathParams.length > 0) {
      mapping.lookupParam = pathParams[pathParams.length - 1]
      mapping.lookupField = determineLookupField(pathParams, modelMatch.model)
    }

    mappings.push(mapping)
  }

  return {
    mappings,
    unmapped,
    skipped,
    availableModels: fixtureModelNames,
  }
}

/**
 * Type guard for supported HTTP methods
 */
function isSupportedMethod(method: string): method is SupportedHttpMethod {
  return ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'].includes(method.toUpperCase())
}

/**
 * Infer mappings from schema models when endpoints are not available
 *
 * This is useful for codebase-derived schemas (TypeScript, Drizzle, etc.)
 * that don't have explicit endpoint definitions.
 *
 * For each model, generates:
 * - GET /{models} -> collection
 * - GET /{models}/:id -> single
 * - POST /{models} -> single
 * - PUT /{models}/:id -> single
 * - DELETE /{models}/:id -> single
 */
export function inferMappingsFromModels(
  models: Record<string, unknown>,
  options: { basePath?: string } = {}
): InferredEndpointMapping[] {
  const basePath = options.basePath || '/api'
  const mappings: InferredEndpointMapping[] = []

  for (const modelName of Object.keys(models)) {
    // Convert model name to URL-friendly plural form
    const urlName = modelName.toLowerCase()
    const pluralName = urlName.endsWith('s') ? urlName : urlName + 's'
    const resourcePath = `${basePath}/${pluralName}`

    // GET collection
    mappings.push({
      method: 'GET',
      pattern: resourcePath,
      sourceModel: modelName,
      responseType: 'collection',
      isAutoGenerated: true,
      confidence: 70,
      reason: `Auto-generated collection endpoint for model "${modelName}"`,
    })

    // GET single by ID
    mappings.push({
      method: 'GET',
      pattern: `${resourcePath}/:id`,
      sourceModel: modelName,
      responseType: 'single',
      lookupField: 'id',
      lookupParam: 'id',
      isAutoGenerated: true,
      confidence: 70,
      reason: `Auto-generated single-record endpoint for model "${modelName}"`,
    })

    // POST create
    mappings.push({
      method: 'POST',
      pattern: resourcePath,
      sourceModel: modelName,
      responseType: 'single',
      isAutoGenerated: true,
      confidence: 70,
      reason: `Auto-generated create endpoint for model "${modelName}"`,
    })

    // PUT update
    mappings.push({
      method: 'PUT',
      pattern: `${resourcePath}/:id`,
      sourceModel: modelName,
      responseType: 'single',
      lookupField: 'id',
      lookupParam: 'id',
      isAutoGenerated: true,
      confidence: 70,
      reason: `Auto-generated update endpoint for model "${modelName}"`,
    })

    // DELETE
    mappings.push({
      method: 'DELETE',
      pattern: `${resourcePath}/:id`,
      sourceModel: modelName,
      responseType: 'single',
      lookupField: 'id',
      lookupParam: 'id',
      isAutoGenerated: true,
      confidence: 70,
      reason: `Auto-generated delete endpoint for model "${modelName}"`,
    })
  }

  return mappings
}
