/**
 * Tests for Mapping Validator Agent
 *
 * Tests cover:
 * - Zod schema validation
 * - Prompt building
 * - Agent configuration
 * - Edge cases
 */

import { describe, it, expect } from 'vitest'
import type { DemokitSchema } from '@demokit-ai/core'
import type { InferredEndpointMapping } from '../../lib/schema-to-mappings'
import {
  createMappingValidatorAgent,
  buildValidationPrompt,
  MappingValidationResultSchema,
  ValidatedMappingSchema,
  ValidationErrorSchema,
  MappingStatusSchema,
  type MappingValidationResult,
  type ValidatedMapping,
  type ValidationError,
} from '../mapping-validator-agent'

// ============================================================================
// Test Fixtures
// ============================================================================

const createMockSchema = (
  endpoints: DemokitSchema['endpoints'] = [],
  models: DemokitSchema['models'] = {}
): DemokitSchema => ({
  info: {
    title: 'Test API',
    version: '1.0.0',
    description: 'A test API for validation',
  },
  endpoints,
  models,
  relationships: [],
})

const createMockMapping = (
  overrides: Partial<InferredEndpointMapping> = {}
): InferredEndpointMapping => ({
  method: 'GET',
  pattern: '/api/users',
  sourceModel: 'users',
  responseType: 'collection',
  isAutoGenerated: true,
  confidence: 100,
  ...overrides,
})

// ============================================================================
// Zod Schema Tests
// ============================================================================

describe('MappingStatusSchema', () => {
  it('accepts valid status values', () => {
    expect(MappingStatusSchema.parse('valid')).toBe('valid')
    expect(MappingStatusSchema.parse('corrected')).toBe('corrected')
    expect(MappingStatusSchema.parse('flagged')).toBe('flagged')
    expect(MappingStatusSchema.parse('removed')).toBe('removed')
  })

  it('rejects invalid status values', () => {
    expect(() => MappingStatusSchema.parse('invalid')).toThrow()
    expect(() => MappingStatusSchema.parse('')).toThrow()
    expect(() => MappingStatusSchema.parse(123)).toThrow()
  })
})

describe('ValidatedMappingSchema', () => {
  it('accepts a valid mapping', () => {
    const mapping: ValidatedMapping = {
      method: 'GET',
      pattern: '/api/users',
      sourceModel: 'users',
      responseType: 'collection',
      status: 'valid',
      confidence: 95,
    }

    expect(ValidatedMappingSchema.parse(mapping)).toEqual(mapping)
  })

  it('accepts a mapping with optional fields', () => {
    const mapping: ValidatedMapping = {
      method: 'GET',
      pattern: '/api/users/:id',
      sourceModel: 'users',
      responseType: 'single',
      lookupField: 'id',
      lookupParam: 'id',
      status: 'corrected',
      originalSourceModel: 'user_accounts',
      reason: 'Fixed model name',
      confidence: 85,
    }

    expect(ValidatedMappingSchema.parse(mapping)).toEqual(mapping)
  })

  it('rejects mapping with invalid responseType', () => {
    const mapping = {
      method: 'GET',
      pattern: '/api/users',
      sourceModel: 'users',
      responseType: 'invalid',
      status: 'valid',
      confidence: 95,
    }

    expect(() => ValidatedMappingSchema.parse(mapping)).toThrow()
  })

  it('rejects mapping with confidence out of range', () => {
    const mappingTooLow = {
      method: 'GET',
      pattern: '/api/users',
      sourceModel: 'users',
      responseType: 'collection',
      status: 'valid',
      confidence: -1,
    }

    const mappingTooHigh = {
      method: 'GET',
      pattern: '/api/users',
      sourceModel: 'users',
      responseType: 'collection',
      status: 'valid',
      confidence: 101,
    }

    expect(() => ValidatedMappingSchema.parse(mappingTooLow)).toThrow()
    expect(() => ValidatedMappingSchema.parse(mappingTooHigh)).toThrow()
  })

  it('accepts boundary confidence values', () => {
    const mappingZero = {
      method: 'GET',
      pattern: '/api/users',
      sourceModel: 'users',
      responseType: 'collection',
      status: 'flagged',
      confidence: 0,
    }

    const mappingHundred = {
      method: 'GET',
      pattern: '/api/users',
      sourceModel: 'users',
      responseType: 'collection',
      status: 'valid',
      confidence: 100,
    }

    expect(ValidatedMappingSchema.parse(mappingZero).confidence).toBe(0)
    expect(ValidatedMappingSchema.parse(mappingHundred).confidence).toBe(100)
  })
})

describe('ValidationErrorSchema', () => {
  it('accepts a valid error', () => {
    const error: ValidationError = {
      pattern: '/api/unknown',
      method: 'GET',
      errorType: 'missing_model',
      message: 'No matching model found',
    }

    expect(ValidationErrorSchema.parse(error)).toEqual(error)
  })

  it('accepts error with suggestion', () => {
    const error: ValidationError = {
      pattern: '/api/orders',
      method: 'GET',
      errorType: 'wrong_response_type',
      message: 'Expected collection but got single',
      suggestion: 'Change responseType to collection',
    }

    expect(ValidationErrorSchema.parse(error)).toEqual(error)
  })

  it('validates all error types', () => {
    const errorTypes = [
      'missing_model',
      'wrong_response_type',
      'invalid_lookup',
      'orphan_endpoint',
      'ambiguous_mapping',
    ]

    errorTypes.forEach((type) => {
      const error = {
        pattern: '/test',
        method: 'GET',
        errorType: type,
        message: 'Test message',
      }
      expect(ValidationErrorSchema.parse(error).errorType).toBe(type)
    })
  })
})

describe('MappingValidationResultSchema', () => {
  it('accepts a valid result', () => {
    const result: MappingValidationResult = {
      isValid: true,
      overallConfidence: 95,
      mappings: [
        {
          method: 'GET',
          pattern: '/api/users',
          sourceModel: 'users',
          responseType: 'collection',
          status: 'valid',
          confidence: 95,
        },
      ],
      errors: [],
      suggestions: ['Consider adding pagination support'],
    }

    expect(MappingValidationResultSchema.parse(result)).toEqual(result)
  })

  it('accepts a result with errors and corrected mappings', () => {
    const result: MappingValidationResult = {
      isValid: false,
      overallConfidence: 75,
      mappings: [
        {
          method: 'GET',
          pattern: '/api/orders',
          sourceModel: 'orders',
          responseType: 'collection',
          status: 'corrected',
          originalSourceModel: 'order_items',
          reason: 'Fixed model association',
          confidence: 80,
        },
      ],
      errors: [
        {
          pattern: '/api/unknown',
          method: 'GET',
          errorType: 'missing_model',
          message: 'No matching model found',
        },
      ],
      suggestions: [],
    }

    expect(MappingValidationResultSchema.parse(result).isValid).toBe(false)
  })

  it('accepts result with empty arrays', () => {
    const result: MappingValidationResult = {
      isValid: true,
      overallConfidence: 100,
      mappings: [],
      errors: [],
      suggestions: [],
    }

    expect(MappingValidationResultSchema.parse(result)).toEqual(result)
  })
})

// ============================================================================
// buildValidationPrompt Tests
// ============================================================================

describe('buildValidationPrompt', () => {
  it('includes fixture models in prompt', () => {
    const schema = createMockSchema()
    const fixtureModels = ['users', 'products', 'orders']
    const mappings = [createMockMapping()]

    const prompt = buildValidationPrompt(schema, fixtureModels, mappings)

    expect(prompt).toContain('Available Fixture Models')
    expect(prompt).toContain('- users')
    expect(prompt).toContain('- products')
    expect(prompt).toContain('- orders')
  })

  it('includes schema summary in prompt', () => {
    const schema = createMockSchema(
      [
        {
          method: 'GET',
          path: '/api/users',
          pathParams: [],
          queryParams: [],
          responses: {},
          tags: [],
          summary: 'Get all users',
        },
      ],
      {
        User: {
          name: 'User',
          type: 'object',
          properties: {
            id: { name: 'id', type: 'string' },
            email: { name: 'email', type: 'string' },
          },
          required: ['id', 'email'],
        },
      }
    )
    const fixtureModels = ['users']
    const mappings = [createMockMapping()]

    const prompt = buildValidationPrompt(schema, fixtureModels, mappings)

    expect(prompt).toContain('API Schema Summary')
    expect(prompt).toContain('Test API')
    expect(prompt).toContain('User')
    expect(prompt).toContain('/api/users')
  })

  it('includes inferred mappings in prompt', () => {
    const schema = createMockSchema()
    const fixtureModels = ['users']
    const mappings = [
      createMockMapping({
        method: 'GET',
        pattern: '/api/users',
        sourceModel: 'users',
        responseType: 'collection',
        confidence: 100,
      }),
      createMockMapping({
        method: 'GET',
        pattern: '/api/users/:id',
        sourceModel: 'users',
        responseType: 'single',
        lookupField: 'id',
        lookupParam: 'id',
        confidence: 95,
      }),
    ]

    const prompt = buildValidationPrompt(schema, fixtureModels, mappings)

    expect(prompt).toContain('Auto-Inferred Mappings to Validate')
    expect(prompt).toContain('/api/users')
    expect(prompt).toContain('/api/users/:id')
    expect(prompt).toContain('"method": "GET"')
    expect(prompt).toContain('"sourceModel": "users"')
    expect(prompt).toContain('"responseType": "collection"')
    expect(prompt).toContain('"responseType": "single"')
  })

  it('handles empty mappings array', () => {
    const schema = createMockSchema()
    const fixtureModels = ['users']
    const mappings: InferredEndpointMapping[] = []

    const prompt = buildValidationPrompt(schema, fixtureModels, mappings)

    expect(prompt).toContain('Auto-Inferred Mappings to Validate')
    expect(prompt).toContain('[]')
  })

  it('handles empty fixture models', () => {
    const schema = createMockSchema()
    const fixtureModels: string[] = []
    const mappings = [createMockMapping()]

    const prompt = buildValidationPrompt(schema, fixtureModels, mappings)

    expect(prompt).toContain('Available Fixture Models')
    // Should not have any model entries
    expect(prompt).not.toContain('- users')
  })

  it('includes only essential mapping properties', () => {
    const schema = createMockSchema()
    const fixtureModels = ['users']
    const mappings = [
      createMockMapping({
        isAutoGenerated: true, // Should be stripped
        reason: 'Test reason', // Should be stripped
      }),
    ]

    const prompt = buildValidationPrompt(schema, fixtureModels, mappings)

    // These properties should NOT appear in the prompt (they're internal)
    expect(prompt).not.toContain('isAutoGenerated')
  })

  it('limits sample endpoints to 10', () => {
    const endpoints = Array.from({ length: 25 }, (_, i) => ({
      method: 'GET' as const,
      path: `/api/endpoint${i + 1}`,
      pathParams: [],
      queryParams: [],
      responses: {},
      tags: [],
    }))

    const schema = createMockSchema(endpoints)
    const fixtureModels = ['users']
    const mappings = [createMockMapping()]

    const prompt = buildValidationPrompt(schema, fixtureModels, mappings)

    expect(prompt).toContain('/api/endpoint1')
    expect(prompt).toContain('/api/endpoint10')
    expect(prompt).not.toContain('/api/endpoint11')
    expect(prompt).not.toContain('/api/endpoint25')
  })

  it('limits relationships to 20', () => {
    const relationships = Array.from({ length: 30 }, (_, i) => ({
      from: { model: `Model${i}`, field: 'id' },
      to: { model: `Related${i}`, field: 'modelId' },
      type: 'one-to-many' as const,
      required: true,
      detectedBy: 'explicit-ref' as const,
    }))

    const schema: DemokitSchema = {
      info: { title: 'Test API', version: '1.0.0' },
      endpoints: [],
      models: {},
      relationships,
    }
    const fixtureModels = ['users']
    const mappings = [createMockMapping()]

    const prompt = buildValidationPrompt(schema, fixtureModels, mappings)

    // Should have relationships in the summary but limited
    expect(prompt).toContain('Model0')
    expect(prompt).toContain('Model19')
    expect(prompt).not.toContain('Model20')
  })
})

// ============================================================================
// createMappingValidatorAgent Tests
// ============================================================================

describe('createMappingValidatorAgent', () => {
  it('creates an agent with correct name', () => {
    const agent = createMappingValidatorAgent()

    expect(agent.name).toBe('demokit-mapping-validator')
  })

  it('agent has instructions', () => {
    const agent = createMappingValidatorAgent()

    // Agent should have instructions property set
    // We can't directly access private properties, but we can verify creation succeeds
    expect(agent).toBeDefined()
  })
})

// ============================================================================
// Edge Cases
// ============================================================================

describe('edge cases', () => {
  describe('schema with special characters', () => {
    it('handles model names with special characters', () => {
      const schema = createMockSchema(
        [],
        {
          'User-Profile': {
            name: 'User-Profile',
            type: 'object',
            properties: {},
          },
        }
      )
      const fixtureModels = ['user-profiles']
      const mappings = [
        createMockMapping({
          pattern: '/api/user-profiles',
          sourceModel: 'user-profiles',
        }),
      ]

      const prompt = buildValidationPrompt(schema, fixtureModels, mappings)

      expect(prompt).toContain('User-Profile')
      expect(prompt).toContain('user-profiles')
    })

    it('handles paths with unicode characters', () => {
      const schema = createMockSchema()
      const fixtureModels = ['users']
      const mappings = [
        createMockMapping({
          pattern: '/api/ユーザー',
          sourceModel: 'users',
        }),
      ]

      const prompt = buildValidationPrompt(schema, fixtureModels, mappings)

      expect(prompt).toContain('/api/ユーザー')
    })
  })

  describe('large inputs', () => {
    it('handles many fixture models', () => {
      const schema = createMockSchema()
      const fixtureModels = Array.from({ length: 100 }, (_, i) => `model${i}`)
      const mappings = [createMockMapping()]

      const prompt = buildValidationPrompt(schema, fixtureModels, mappings)

      expect(prompt).toContain('model0')
      expect(prompt).toContain('model99')
    })

    it('handles many mappings', () => {
      const schema = createMockSchema()
      const fixtureModels = ['users']
      const mappings = Array.from({ length: 50 }, (_, i) =>
        createMockMapping({
          pattern: `/api/endpoint${i}`,
        })
      )

      const prompt = buildValidationPrompt(schema, fixtureModels, mappings)

      expect(prompt).toContain('/api/endpoint0')
      expect(prompt).toContain('/api/endpoint49')
    })
  })

  describe('null and undefined handling', () => {
    it('handles schema with minimal info', () => {
      const schema: DemokitSchema = {
        info: {
          title: '',
          version: '',
        },
        endpoints: [],
        models: {},
        relationships: [],
      }
      const fixtureModels = ['users']
      const mappings = [createMockMapping()]

      // Should not throw
      const prompt = buildValidationPrompt(schema, fixtureModels, mappings)
      expect(prompt).toBeDefined()
    })
  })
})
