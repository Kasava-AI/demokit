/**
 * Tests for FixtureDetail component export logic
 *
 * Tests cover copy, download, and save functionality for all export formats:
 * - TypeScript (.ts)
 * - JSON (.json)
 * - SQL (.sql)
 * - CSV (.csv)
 *
 * @vitest-environment jsdom
 */
import { describe, it, expect, vi, beforeEach, afterEach } from "vitest";
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import React from "react";

// Mock window.matchMedia for tests
Object.defineProperty(window, "matchMedia", {
  writable: true,
  value: vi.fn().mockImplementation((query) => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: vi.fn(),
    removeListener: vi.fn(),
    addEventListener: vi.fn(),
    removeEventListener: vi.fn(),
    dispatchEvent: vi.fn(),
  })),
});

// Mock Collapsible components to always show content
vi.mock("@/components/ui/collapsible", () => ({
  Collapsible: ({ children, open }: { children: React.ReactNode; open?: boolean }) => (
    <div data-state={open ? "open" : "closed"}>{children}</div>
  ),
  CollapsibleTrigger: ({ children }: { children: React.ReactNode }) => (
    <>{children}</>
  ),
  CollapsibleContent: ({ children }: { children: React.ReactNode }) => (
    <div>{children}</div>
  ),
}));

import { FixtureDetail } from "../FixtureDetail";
import type {
  DemoData,
  DemoNarrative,
  ValidationResult,
} from "../components/types";

// Mock @demokit-ai/core formatters
vi.mock("@demokit-ai/core", () => ({
  formatAsTypeScript: vi.fn(
    (
      data: DemoData,
      options?: {
        asConst?: boolean;
        includeHeader?: boolean;
        narrative?: DemoNarrative;
      }
    ) => {
      const header = options?.includeHeader
        ? "// Generated by DemoKit\n// Narrative: Test scenario\n\n"
        : "";
      const asConst = options?.asConst ? " as const" : "";
      return `${header}export const users = ${JSON.stringify(
        data.User,
        null,
        2
      )}${asConst};`;
    }
  ),
  formatAsJSON: vi.fn((data: DemoData) => JSON.stringify(data, null, 2)),
  formatAsSQL: vi.fn((data: DemoData) => {
    const records = data.User || [];
    return records
      .map(
        (r: Record<string, unknown>) =>
          `INSERT INTO users (id, email, name) VALUES ('${r.id}', '${r.email}', '${r.name}');`
      )
      .join("\n");
  }),
  formatAsCSV: vi.fn((data: DemoData, model: string) => {
    const records = data[model] || [];
    if (records.length === 0) return "";
    const headers = Object.keys(records[0]).join(",");
    const rows = records.map((r: Record<string, unknown>) =>
      Object.values(r).join(",")
    );
    return [headers, ...rows].join("\n");
  }),
}));

import {
  formatAsTypeScript,
  formatAsJSON,
  formatAsSQL,
  formatAsCSV,
} from "@demokit-ai/core";

// Sample test data
const mockData: DemoData = {
  User: [
    { id: "user-1", email: "alice@example.com", name: "Alice" },
    { id: "user-2", email: "bob@example.com", name: "Bob" },
  ],
  Product: [
    { id: "prod-1", name: "Widget", price: 9.99 },
    { id: "prod-2", name: "Gadget", price: 19.99 },
  ],
};

const mockNarrative: DemoNarrative = {
  scenario: "E-commerce test data",
  seedPhrase: "test-seed-123",
};

const mockValidation: ValidationResult = {
  valid: true,
  errors: [],
  warnings: [],
  stats: {
    totalRecords: 4,
    recordsByModel: { User: 2, Product: 2 },
    relationshipsChecked: 0,
    typeChecks: 4,
    durationMs: 10,
  },
};

const mockCode = `// Generated fixture data
export const users = [
  { id: 'user-1', email: 'alice@example.com', name: 'Alice' },
  { id: 'user-2', email: 'bob@example.com', name: 'Bob' },
] as const;`;

// Mock clipboard API
const mockWriteText = vi.fn().mockResolvedValue(undefined);

// Mock URL APIs
const mockCreateObjectURL = vi.fn(() => "blob:http://localhost/mock-url");
const mockRevokeObjectURL = vi.fn();

// Track created anchor elements
let createdAnchors: { href: string; download: string; clicked: boolean }[] = [];

describe("FixtureDetail", () => {
  beforeEach(() => {
    vi.clearAllMocks();
    createdAnchors = [];

    // Setup clipboard mock
    Object.defineProperty(navigator, "clipboard", {
      value: { writeText: mockWriteText },
      writable: true,
      configurable: true,
    });

    // Setup URL mocks
    global.URL.createObjectURL = mockCreateObjectURL;
    global.URL.revokeObjectURL = mockRevokeObjectURL;

    // Track anchor element creation for downloads
    const originalCreateElement = document.createElement.bind(document);
    vi.spyOn(document, "createElement").mockImplementation(
      (tagName: string) => {
        const element = originalCreateElement(tagName);
        if (tagName === "a") {
          const anchor = {
            href: "",
            download: "",
            clicked: false,
          };
          createdAnchors.push(anchor);

          Object.defineProperty(element, "href", {
            set: (value) => {
              anchor.href = value;
            },
            get: () => anchor.href,
          });
          Object.defineProperty(element, "download", {
            set: (value) => {
              anchor.download = value;
            },
            get: () => anchor.download,
          });
          element.click = () => {
            anchor.clicked = true;
          };
        }
        return element;
      }
    );
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe("Copy functionality", () => {
    it("copies TypeScript format to clipboard", async () => {
      render(
        <FixtureDetail
          data={mockData}
          code={mockCode}
          validation={mockValidation}
          format="typescript"
          narrative={mockNarrative}
        />
      );

      // Switch to code view
      fireEvent.click(screen.getByRole("button", { name: /code/i }));

      // Click the copy button using data-testid
      const copyBtn = screen.getByTestId("copy-button");
      fireEvent.click(copyBtn);

      await waitFor(() => {
        expect(mockWriteText).toHaveBeenCalledTimes(1);
        // Should use preformatted code when available
        expect(mockWriteText).toHaveBeenCalledWith(mockCode);
      });
    });

    it("copies TypeScript format using formatter when no preformatted code", async () => {
      render(
        <FixtureDetail
          data={mockData}
          validation={mockValidation}
          format="typescript"
          narrative={mockNarrative}
        />
      );

      // Switch to code view
      fireEvent.click(screen.getByRole("button", { name: /code/i }));

      // Click copy
      const copyBtn = screen.getByTestId("copy-button");
      fireEvent.click(copyBtn);

      await waitFor(() => {
        expect(mockWriteText).toHaveBeenCalledTimes(1);
        expect(formatAsTypeScript).toHaveBeenCalledWith(
          mockData,
          expect.objectContaining({
            asConst: true,
            includeHeader: true,
            narrative: mockNarrative,
          })
        );
      });
    });

    it("copies JSON format to clipboard", async () => {
      render(
        <FixtureDetail
          data={mockData}
          validation={mockValidation}
          format="typescript"
        />
      );

      // Switch to code view
      fireEvent.click(screen.getByRole("button", { name: /code/i }));

      // Change format to JSON using the select element
      const formatSelect = screen.getByDisplayValue("TypeScript");
      fireEvent.change(formatSelect, { target: { value: "json" } });

      // Click copy
      const copyBtn = screen.getByTestId("copy-button");
      fireEvent.click(copyBtn);

      await waitFor(() => {
        expect(mockWriteText).toHaveBeenCalledTimes(1);
        expect(formatAsJSON).toHaveBeenCalledWith(
          mockData,
          expect.objectContaining({
            indent: 2,
            includeMetadata: true,
          })
        );
      });
    });

    it("copies SQL format to clipboard", async () => {
      render(
        <FixtureDetail
          data={mockData}
          validation={mockValidation}
          format="typescript"
        />
      );

      // Switch to code view
      fireEvent.click(screen.getByRole("button", { name: /code/i }));

      // Change format to SQL
      const formatSelect = screen.getByDisplayValue("TypeScript");
      fireEvent.change(formatSelect, { target: { value: "sql" } });

      // Click copy
      const copyBtn = screen.getByTestId("copy-button");
      fireEvent.click(copyBtn);

      await waitFor(() => {
        expect(mockWriteText).toHaveBeenCalledTimes(1);
        expect(formatAsSQL).toHaveBeenCalledWith(mockData);
      });
    });

    it("copies CSV format to clipboard for selected model", async () => {
      render(
        <FixtureDetail
          data={mockData}
          validation={mockValidation}
          format="typescript"
        />
      );

      // Switch to code view
      fireEvent.click(screen.getByRole("button", { name: /code/i }));

      // Change format to CSV
      const formatSelect = screen.getByDisplayValue("TypeScript");
      fireEvent.change(formatSelect, { target: { value: "csv" } });

      // Click copy
      const copyBtn = screen.getByTestId("copy-button");
      fireEvent.click(copyBtn);

      await waitFor(() => {
        expect(mockWriteText).toHaveBeenCalledTimes(1);
        // Should default to first model (User)
        expect(formatAsCSV).toHaveBeenCalledWith(mockData, "User");
      });
    });

    it("copies CSV format for specific selected model", async () => {
      render(
        <FixtureDetail
          data={mockData}
          validation={mockValidation}
          format="typescript"
        />
      );

      // Switch to code view
      fireEvent.click(screen.getByRole("button", { name: /code/i }));

      // Change format to CSV
      const formatSelect = screen.getByDisplayValue("TypeScript");
      fireEvent.change(formatSelect, { target: { value: "csv" } });

      // Select Product model
      const modelSelect = screen.getByDisplayValue("User");
      fireEvent.change(modelSelect, { target: { value: "Product" } });

      // Click copy
      const copyBtn = screen.getByTestId("copy-button");
      fireEvent.click(copyBtn);

      await waitFor(() => {
        expect(mockWriteText).toHaveBeenCalledTimes(1);
        expect(formatAsCSV).toHaveBeenCalledWith(mockData, "Product");
      });
    });
  });

  describe("Download functionality", () => {
    it("downloads TypeScript file with correct extension", async () => {
      const onExport = vi.fn();

      render(
        <FixtureDetail
          data={mockData}
          code={mockCode}
          validation={mockValidation}
          format="typescript"
          onExport={onExport}
        />
      );

      // Switch to code view
      fireEvent.click(screen.getByRole("button", { name: /code/i }));

      // Click download using data-testid
      const downloadBtn = screen.getByTestId("download-button");
      fireEvent.click(downloadBtn);

      await waitFor(() => {
        expect(mockCreateObjectURL).toHaveBeenCalledWith(expect.any(Blob));
        expect(createdAnchors.length).toBeGreaterThan(0);
        const lastAnchor = createdAnchors[createdAnchors.length - 1];
        expect(lastAnchor.download).toBe("fixtures.ts");
        expect(lastAnchor.clicked).toBe(true);
        expect(mockRevokeObjectURL).toHaveBeenCalled();
      });

      expect(onExport).toHaveBeenCalledWith({
        format: "typescript",
        modelName: undefined,
        timestamp: expect.any(String),
      });
    });

    it("downloads JSON file with correct extension", async () => {
      const onExport = vi.fn();

      render(
        <FixtureDetail
          data={mockData}
          validation={mockValidation}
          format="typescript"
          onExport={onExport}
        />
      );

      // Switch to code view
      fireEvent.click(screen.getByRole("button", { name: /code/i }));

      // Change format to JSON
      const formatSelect = screen.getByDisplayValue("TypeScript");
      fireEvent.change(formatSelect, { target: { value: "json" } });

      // Click download
      const downloadBtn = screen.getByTestId("download-button");
      fireEvent.click(downloadBtn);

      await waitFor(() => {
        const lastAnchor = createdAnchors[createdAnchors.length - 1];
        expect(lastAnchor.download).toBe("fixtures.json");
        expect(lastAnchor.clicked).toBe(true);
      });

      expect(onExport).toHaveBeenCalledWith({
        format: "json",
        modelName: undefined,
        timestamp: expect.any(String),
      });
    });

    it("downloads SQL file with correct extension", async () => {
      const onExport = vi.fn();

      render(
        <FixtureDetail
          data={mockData}
          validation={mockValidation}
          format="typescript"
          onExport={onExport}
        />
      );

      // Switch to code view
      fireEvent.click(screen.getByRole("button", { name: /code/i }));

      // Change format to SQL
      const formatSelect = screen.getByDisplayValue("TypeScript");
      fireEvent.change(formatSelect, { target: { value: "sql" } });

      // Click download
      const downloadBtn = screen.getByTestId("download-button");
      fireEvent.click(downloadBtn);

      await waitFor(() => {
        const lastAnchor = createdAnchors[createdAnchors.length - 1];
        expect(lastAnchor.download).toBe("fixtures.sql");
        expect(lastAnchor.clicked).toBe(true);
      });

      expect(onExport).toHaveBeenCalledWith({
        format: "sql",
        modelName: undefined,
        timestamp: expect.any(String),
      });
    });

    it("downloads CSV file with model name in filename", async () => {
      const onExport = vi.fn();

      render(
        <FixtureDetail
          data={mockData}
          validation={mockValidation}
          format="typescript"
          onExport={onExport}
        />
      );

      // Switch to code view
      fireEvent.click(screen.getByRole("button", { name: /code/i }));

      // Change format to CSV
      const formatSelect = screen.getByDisplayValue("TypeScript");
      fireEvent.change(formatSelect, { target: { value: "csv" } });

      // Click download
      const downloadBtn = screen.getByTestId("download-button");
      fireEvent.click(downloadBtn);

      await waitFor(() => {
        // Should include model name (lowercase) in filename
        const lastAnchor = createdAnchors[createdAnchors.length - 1];
        expect(lastAnchor.download).toBe("fixtures-user.csv");
        expect(lastAnchor.clicked).toBe(true);
      });

      expect(onExport).toHaveBeenCalledWith({
        format: "csv",
        modelName: "User",
        timestamp: expect.any(String),
      });
    });

    it("downloads CSV for specific selected model", async () => {
      const onExport = vi.fn();

      render(
        <FixtureDetail
          data={mockData}
          validation={mockValidation}
          format="typescript"
          onExport={onExport}
        />
      );

      // Switch to code view
      fireEvent.click(screen.getByRole("button", { name: /code/i }));

      // Change format to CSV
      const formatSelect = screen.getByDisplayValue("TypeScript");
      fireEvent.change(formatSelect, { target: { value: "csv" } });

      // Select Product model
      const modelSelect = screen.getByDisplayValue("User");
      fireEvent.change(modelSelect, { target: { value: "Product" } });

      // Click download
      const downloadBtn = screen.getByTestId("download-button");
      fireEvent.click(downloadBtn);

      await waitFor(() => {
        const lastAnchor = createdAnchors[createdAnchors.length - 1];
        expect(lastAnchor.download).toBe("fixtures-product.csv");
        expect(formatAsCSV).toHaveBeenCalledWith(mockData, "Product");
      });

      expect(onExport).toHaveBeenCalledWith({
        format: "csv",
        modelName: "Product",
        timestamp: expect.any(String),
      });
    });

    it("cleans up blob URL after download", async () => {
      render(
        <FixtureDetail
          data={mockData}
          code={mockCode}
          validation={mockValidation}
        />
      );

      // Switch to code view
      fireEvent.click(screen.getByRole("button", { name: /code/i }));

      // Click download
      const downloadBtn = screen.getByTestId("download-button");
      fireEvent.click(downloadBtn);

      await waitFor(() => {
        expect(mockRevokeObjectURL).toHaveBeenCalledWith(
          "blob:http://localhost/mock-url"
        );
      });
    });
  });

  describe("Save functionality", () => {
    it("calls onSave callback when save button clicked", async () => {
      const onSave = vi.fn();

      render(
        <FixtureDetail
          data={mockData}
          code={mockCode}
          validation={mockValidation}
          onSave={onSave}
        />
      );

      // Save button appears in header, use data-testid
      const saveButton = screen.getByTestId("save-button");
      fireEvent.click(saveButton);

      await waitFor(() => {
        expect(onSave).toHaveBeenCalledTimes(1);
      });
    });

    it("does not show save button when onSave is not provided", () => {
      render(
        <FixtureDetail
          data={mockData}
          code={mockCode}
          validation={mockValidation}
        />
      );

      // Save button should not exist when onSave is not provided
      expect(screen.queryByTestId("save-button")).toBeNull();
    });
  });

  describe("Edge cases", () => {
    it("handles empty data gracefully", () => {
      render(<FixtureDetail validation={mockValidation} />);

      expect(screen.getByText("No fixtures generated yet")).toBeTruthy();
    });

    it("shows loading state", () => {
      render(
        <FixtureDetail
          data={mockData}
          validation={mockValidation}
          loading={true}
        />
      );

      expect(screen.getByText("Generating fixtures...")).toBeTruthy();
    });

    it("uses preformatted code for TypeScript when available", async () => {
      render(
        <FixtureDetail
          data={mockData}
          code={mockCode}
          validation={mockValidation}
          format="typescript"
        />
      );

      // Switch to code view
      fireEvent.click(screen.getByRole("button", { name: /code/i }));

      // Click copy
      const copyBtn = screen.getByTestId("copy-button");
      fireEvent.click(copyBtn);

      await waitFor(() => {
        expect(mockWriteText).toHaveBeenCalledWith(mockCode);
        // Should NOT call formatter when preformatted code is provided
        expect(formatAsTypeScript).not.toHaveBeenCalled();
      });
    });
  });

  describe("Export tracking", () => {
    it("tracks export with format and timestamp for TypeScript", async () => {
      const onExport = vi.fn();

      render(
        <FixtureDetail
          data={mockData}
          code={mockCode}
          validation={mockValidation}
          format="typescript"
          onExport={onExport}
        />
      );

      // Switch to code view
      fireEvent.click(screen.getByRole("button", { name: /code/i }));

      // Click download
      const downloadBtn = screen.getByTestId("download-button");
      fireEvent.click(downloadBtn);

      expect(onExport).toHaveBeenCalledWith({
        format: "typescript",
        modelName: undefined,
        timestamp: expect.stringMatching(/^\d{4}-\d{2}-\d{2}T/), // ISO timestamp
      });
    });

    it("tracks export with model name for CSV", async () => {
      const onExport = vi.fn();

      render(
        <FixtureDetail
          data={mockData}
          validation={mockValidation}
          format="typescript"
          onExport={onExport}
        />
      );

      // Switch to code view
      fireEvent.click(screen.getByRole("button", { name: /code/i }));

      // Change format to CSV
      const formatSelect = screen.getByDisplayValue("TypeScript");
      fireEvent.change(formatSelect, { target: { value: "csv" } });

      // Click download
      const downloadBtn = screen.getByTestId("download-button");
      fireEvent.click(downloadBtn);

      expect(onExport).toHaveBeenCalledWith({
        format: "csv",
        modelName: "User", // First model by default
        timestamp: expect.any(String),
      });
    });

    it("does not track export when onExport not provided", async () => {
      render(
        <FixtureDetail
          data={mockData}
          code={mockCode}
          validation={mockValidation}
        />
      );

      // Switch to code view
      fireEvent.click(screen.getByRole("button", { name: /code/i }));

      // Should not throw when downloading without onExport
      const downloadBtn = screen.getByTestId("download-button");

      expect(() => {
        fireEvent.click(downloadBtn);
      }).not.toThrow();
    });
  });
});
