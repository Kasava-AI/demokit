/**
 * Endpoint Mappings API Route (OSS)
 *
 * GET/POST/DELETE operations for fixture endpoint mappings.
 */

import { NextResponse } from 'next/server'
import { getAuthenticatedUser } from '@/lib/api/auth'
import { getDb } from '@/lib/api/db'
import { notFound, handleError } from '@/lib/api/utils'
import {
  createEndpointMappingSchema,
  bulkCreateEndpointMappingsSchema,
} from '@/lib/api/schemas'
import { projects, fixtures, endpointMappings } from '@db'
import { eq, and } from 'drizzle-orm'

type RouteParams = { params: Promise<{ id: string; fixtureId: string }> }

/**
 * GET /api/projects/[id]/fixtures/[fixtureId]/mappings
 * Returns all endpoint mappings for a fixture.
 */
export async function GET(request: Request, { params }: RouteParams) {
  try {
    const { id, fixtureId } = await params
    await getAuthenticatedUser()

    const db = getDb()

    // Verify project exists
    const project = await db.query.projects.findFirst({
      where: eq(projects.id, id),
    })

    if (!project) {
      return notFound('Project')
    }

    // Verify fixture exists
    const fixture = await db.query.fixtures.findFirst({
      where: and(eq(fixtures.id, fixtureId), eq(fixtures.projectId, id)),
    })

    if (!fixture) {
      return notFound('Fixture')
    }

    const mappings = await db.query.endpointMappings.findMany({
      where: eq(endpointMappings.fixtureId, fixtureId),
      orderBy: (m, { asc, desc }) => [desc(m.priority), asc(m.pattern)],
    })

    return NextResponse.json(mappings)
  } catch (error) {
    return handleError(error, 'GET /api/projects/[id]/fixtures/[fixtureId]/mappings')
  }
}

/**
 * POST /api/projects/[id]/fixtures/[fixtureId]/mappings
 * Creates a new endpoint mapping for a fixture.
 * Supports single mapping or bulk creation via { mappings: [...] }
 */
export async function POST(request: Request, { params }: RouteParams) {
  try {
    const { id, fixtureId } = await params
    await getAuthenticatedUser()

    const db = getDb()

    // Verify project exists
    const project = await db.query.projects.findFirst({
      where: eq(projects.id, id),
    })

    if (!project) {
      return notFound('Project')
    }

    // Verify fixture exists
    const fixture = await db.query.fixtures.findFirst({
      where: and(eq(fixtures.id, fixtureId), eq(fixtures.projectId, id)),
    })

    if (!fixture) {
      return notFound('Fixture')
    }

    const body = await request.json()

    // Check if this is a bulk creation request
    if ('mappings' in body && Array.isArray(body.mappings)) {
      const validatedData = bulkCreateEndpointMappingsSchema.parse(body)

      const createdMappings = await db
        .insert(endpointMappings)
        .values(
          validatedData.mappings.map((mapping) => ({
            fixtureId,
            method: mapping.method,
            pattern: mapping.pattern,
            sourceModel: mapping.sourceModel,
            responseType: mapping.responseType,
            lookupField: mapping.lookupField,
            lookupParam: mapping.lookupParam,
            transformCode: mapping.transformCode,
            isAutoGenerated: mapping.isAutoGenerated,
            priority: mapping.priority,
          }))
        )
        .returning()

      return NextResponse.json(createdMappings, { status: 201 })
    }

    // Single mapping creation
    const validatedData = createEndpointMappingSchema.parse(body)

    const [mapping] = await db
      .insert(endpointMappings)
      .values({
        fixtureId,
        method: validatedData.method,
        pattern: validatedData.pattern,
        sourceModel: validatedData.sourceModel,
        responseType: validatedData.responseType,
        lookupField: validatedData.lookupField,
        lookupParam: validatedData.lookupParam,
        transformCode: validatedData.transformCode,
        isAutoGenerated: validatedData.isAutoGenerated,
        priority: validatedData.priority,
      })
      .returning()

    return NextResponse.json(mapping, { status: 201 })
  } catch (error) {
    return handleError(error, 'POST /api/projects/[id]/fixtures/[fixtureId]/mappings')
  }
}

/**
 * DELETE /api/projects/[id]/fixtures/[fixtureId]/mappings
 * Deletes all endpoint mappings for a fixture.
 * Useful for regenerating mappings.
 */
export async function DELETE(request: Request, { params }: RouteParams) {
  try {
    const { id, fixtureId } = await params
    await getAuthenticatedUser()

    const db = getDb()

    // Verify project exists
    const project = await db.query.projects.findFirst({
      where: eq(projects.id, id),
    })

    if (!project) {
      return notFound('Project')
    }

    // Verify fixture exists
    const fixture = await db.query.fixtures.findFirst({
      where: and(eq(fixtures.id, fixtureId), eq(fixtures.projectId, id)),
    })

    if (!fixture) {
      return notFound('Fixture')
    }

    await db.delete(endpointMappings).where(eq(endpointMappings.fixtureId, fixtureId))

    return NextResponse.json({ success: true })
  } catch (error) {
    return handleError(error, 'DELETE /api/projects/[id]/fixtures/[fixtureId]/mappings')
  }
}
